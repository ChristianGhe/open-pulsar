## Quick Fixes

- Read agent-loop.sh in full, focusing on parse_tasks, flush_task, init_state, check_dependencies, and write_daily_log. Then implement these five targeted fixes: (1) strip CRLF at the top of parse_tasks's while loop body: `line="${line%$'\r'}"` — this prevents carriage returns from corrupting group names, task text, slugs, and jq values when task files have Windows line endings; (2) in flush_task, reset `in_multiline=false` unconditionally (outside the `if [[ -n "$current_task" ]]` guard) so that a flush on an empty task still resets the multiline state; (3) in init_state, cap group_slug to 30 characters: change `group_slug=$(slugify "$group")` to `group_slug=$(slugify "$group" | cut -c1-30)` to match the existing 50-char cap on task_slug and prevent overly long log filenames; (4) in write_daily_log, change the filename format from `date +%d%m%Y` to `date +%Y-%m-%d` so daily log files sort lexicographically in chronological order and are consistent with the ISO 8601 timestamps written inside the file; (5) in check_dependencies, add a check for sha256sum with the message "Error: sha256sum is required (macOS: brew install coreutils)" so users get a clear error at startup instead of a cryptic failure inside init_state.

## Session & Compaction Fixes

- Read agent-loop.sh focusing on execute_tasks (the group-boundary block and the COMPACTION_SUMMARY variable) and show_status. Fix two bugs: (1) in the group-boundary block inside execute_tasks where session_id and SESSION_TOKENS are reset, also reset COMPACTION_SUMMARY to "" — without this, a compaction triggered at the end of one group injects that group's session summary into the first task of the next group; (2) in show_status, add a running count extracted from state.json (`running=$(jq '[.tasks[] | select(.status == "running")] | length' "$STATE_FILE")`), subtract it from the pending calculation alongside completed/failed/interrupted, and display tasks with status "running" with symbol `RUN` in the status table so that tasks stuck in "running" after a SIGKILL are surfaced clearly.

## run_claude Refactor

- Read agent-loop.sh focusing on run_claude (the echo return at the end) and execute_tasks (the cut -d: parsing block). Replace the colon-delimited return protocol with three module-level named globals: `_RUN_SESSION_ID=""`, `_RUN_TOKENS=0`, `_RUN_CONTEXT_WINDOW=200000`. In run_claude, instead of `echo "${new_session_id}:${token_info}"`, assign these three globals directly and `return 0`. In execute_tasks, remove the `claude_output=$(run_claude ...)` capture and the three `cut -d:` lines; instead call `run_claude ...` directly (capturing its exit code with `|| run_exit=$?`) and read `$_RUN_SESSION_ID`, `$_RUN_TOKENS`, `$_RUN_CONTEXT_WINDOW`. This eliminates the fragility of colon-splitting and makes session ID format changes safe. Also in run_claude, redirect stderr to a temp file (`2>"$stderr_file"`) instead of merging it with stdout (`2>&1`), so that jq always receives clean JSON; on non-zero exit, append the stderr file contents to the task log for diagnostics, then delete it.

## jj & Interrupt Fixes

- Read agent-loop.sh focusing on jj_new_change, jj_abandon_change, and the execute_tasks block around jj_change creation. Fix three issues: (1) in jj_new_change, after `jj log` fails, return the empty string instead of "unknown" — `echo ""` — so the caller gets a falsy value; correspondingly, in jj_abandon_change, the existing `[[ -n "$change_id" && "$change_id" != "null" ]]` guard already rejects empty string, so no change needed there; (2) in execute_tasks, call `update_task_state "$i" "jj_change" "$jj_change"` immediately after `jj_new_change` returns and before any other work, so that an interrupt arriving after jj change creation but before state persistence doesn't orphan the change (the interrupt handler reads jj_change from state to abandon it); (3) at the start of main (after init_state), scan state.json for tasks with status "running" and downgrade them to "interrupted" with a warning printed to stderr — this makes SIGKILL recovery consistent with the existing interrupt-resume path.

## analyze_failure & Model Failover

- Read agent-loop.sh focusing on analyze_failure (the hardcoded "haiku") and the model-failover logic in execute_tasks (the MODEL toggle and post-task reset). Make two changes: (1) replace the hardcoded `--model haiku` in analyze_failure with `--model "${ANALYSIS_MODEL:-haiku}"`, and declare `ANALYSIS_MODEL="${ANALYSIS_MODEL:-haiku}"` near the other model variables at the top of the script so it can be overridden via environment; (2) instead of unconditionally resetting `MODEL="$ORIGINAL_MODEL"` after every task, track a `_LAST_SUCCESSFUL_MODEL` variable updated to `$MODEL` whenever a task completes successfully, and start each new task with `MODEL="$_LAST_SUCCESSFUL_MODEL"` (defaulting to ORIGINAL_MODEL at init) — this avoids wasting one attempt per task when the primary model has a sustained rate limit, without changing the toggle logic on retry.

## Tests: Slugify, Daily Log, show_status

- Read tests/test-features.sh and agent-loop.sh (slugify, write_daily_log, show_status). Add three new test sections to tests/test-features.sh: (1) slugify — source the function, then assert: "Hello World" → "hello-world", "  foo---bar  " → "foo-bar", "---leading" → "leading", "trailing---" → "trailing", a 60-character input produces a slug ≤ 30 chars when piped through `cut -c1-30`; (2) write_daily_log — call it with mock values in a temp directory, assert the log file is created with a YYYY-MM-DD filename (not DDMMYYYY), the entry contains the task group and task name, and a result string longer than 300 chars is truncated to 300 in the log; (3) show_status — create a minimal state.json with one completed, one failed, one interrupted, and one running task, call show_status, and assert the output contains "OK", "FAIL", "INT", "RUN", and that the pending count is 0 (not 1, which would happen if "running" were not subtracted).

## Tests: parse_tasks

- Read tests/test-features.sh and agent-loop.sh (parse_tasks, flush_task, show_parsed_tasks). Add a new test section to tests/test-features.sh that exercises parse_tasks in isolation by sourcing the relevant functions from agent-loop.sh. For each test case, reset TASK_GROUPS, TASK_TEXTS, and TOTAL_TASKS to empty/zero, write a temp task file, call parse_tasks on it, then assert on the arrays. Cover: (1) basic group + task assignment (group name and task text correct); (2) multiline task (indented continuation joined with space); (3) tasks with no ## heading assigned to group "ungrouped"; (4) multiple groups, multiple tasks each — correct group assignment throughout; (5) empty file → TOTAL_TASKS=0, no crash; (6) file with only headings, no tasks → TOTAL_TASKS=0; (7) CRLF line endings stripped from group name and task text (no trailing \r); (8) task immediately followed by ## heading without blank line — task is flushed correctly before new group starts.
