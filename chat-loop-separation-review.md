## Review: Chat / Loop Independence

- Read `telegram-agent.py` and `agent-loop.sh` in full. Then produce a written design review saved to `.agent-loop/chat-loop-separation-review.md` covering: (1) **Current coupling** — identify every point where the two processes are tightly coupled today: `telegram-agent.py` spawning `agent-loop.sh` as a subprocess, the shared `.agent-loop/` directory layout, ephemeral task files created by the chat agent, the `ThreadPoolExecutor` lifecycle tied to the Telegram polling loop, and the fact that `_run_agent_loop_task` both creates the task file and blocks on the subprocess; (2) **What "independent" means** — define the target: `agent-loop.sh` should be startable and stoppable on its own without `telegram-agent.py` managing its lifecycle; the chat agent should submit work and receive results without holding a subprocess handle; the two components should survive each other restarting; (3) **Approach comparison** — evaluate at least these four approaches: (a) filesystem task queue — the chat agent drops `.md` task files into a watched inbox directory and polls a results file or state.json for completion; (b) Unix named pipe / FIFO — the chat agent writes task descriptors to a pipe that agent-loop reads; (c) SQLite queue — shared lightweight database as a job queue with status tracking; (d) process supervision with a coordinator script — a thin shell wrapper that watches an inbox dir and calls agent-loop for each file, decoupling the two completely; for each approach cover: how task submission works, how the result gets back to the chat agent, what happens when either process restarts mid-task, concurrency model, and implementation complexity; (4) **Recommendation** — pick the approach that best fits the existing architecture (bash + Python, no external services), explain the trade-offs clearly, and sketch the minimal changes needed to `telegram-agent.py` and `agent-loop.sh` (or a new coordinator) to implement it.
